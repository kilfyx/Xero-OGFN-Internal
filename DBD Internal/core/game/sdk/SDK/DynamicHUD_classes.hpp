#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DynamicHUD

#include "Basic.hpp"

#include "DynamicHUD_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SlateCore_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class DynamicHUD.DynamicHUDDirectorBase
// 0x0018 (0x0238 - 0x0220)
class ADynamicHUDDirectorBase final : public AActor
{
public:
	TArray<class UDynamicHUDScene*>               DefaultScenes;                                     // 0x0220(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicHUDWidgetCatalog*               WidgetCatalog;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDDirectorBase">();
	}
	static class ADynamicHUDDirectorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicHUDDirectorBase>();
	}
};
static_assert(alignof(ADynamicHUDDirectorBase) == 0x000008, "Wrong alignment on ADynamicHUDDirectorBase");
static_assert(sizeof(ADynamicHUDDirectorBase) == 0x000238, "Wrong size on ADynamicHUDDirectorBase");
static_assert(offsetof(ADynamicHUDDirectorBase, DefaultScenes) == 0x000220, "Member 'ADynamicHUDDirectorBase::DefaultScenes' has a wrong offset!");
static_assert(offsetof(ADynamicHUDDirectorBase, WidgetCatalog) == 0x000230, "Member 'ADynamicHUDDirectorBase::WidgetCatalog' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintBase
// 0x0008 (0x0030 - 0x0028)
class UDynamicHUDConstraintBase : public UObject
{
public:
	EDynamicHUDStrength                           Strength;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintBase">();
	}
	static class UDynamicHUDConstraintBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintBase>();
	}
};
static_assert(alignof(UDynamicHUDConstraintBase) == 0x000008, "Wrong alignment on UDynamicHUDConstraintBase");
static_assert(sizeof(UDynamicHUDConstraintBase) == 0x000030, "Wrong size on UDynamicHUDConstraintBase");
static_assert(offsetof(UDynamicHUDConstraintBase, Strength) == 0x000028, "Member 'UDynamicHUDConstraintBase::Strength' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintPosition
// 0x0040 (0x0070 - 0x0030)
class UDynamicHUDConstraintPosition final : public UDynamicHUDConstraintBase
{
public:
	TSoftClassPtr<class UClass>                   Widget;                                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDAnchor                             Anchor;                                            // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintPosition">();
	}
	static class UDynamicHUDConstraintPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintPosition>();
	}
};
static_assert(alignof(UDynamicHUDConstraintPosition) == 0x000008, "Wrong alignment on UDynamicHUDConstraintPosition");
static_assert(sizeof(UDynamicHUDConstraintPosition) == 0x000070, "Wrong size on UDynamicHUDConstraintPosition");
static_assert(offsetof(UDynamicHUDConstraintPosition, Widget) == 0x000030, "Member 'UDynamicHUDConstraintPosition::Widget' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintPosition, Tag) == 0x000058, "Member 'UDynamicHUDConstraintPosition::Tag' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintPosition, Position) == 0x000060, "Member 'UDynamicHUDConstraintPosition::Position' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintPosition, Anchor) == 0x000068, "Member 'UDynamicHUDConstraintPosition::Anchor' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintAlignment
// 0x0038 (0x0068 - 0x0030)
class UDynamicHUDConstraintAlignment final : public UDynamicHUDConstraintBase
{
public:
	TSoftClassPtr<class UClass>                   Widget;                                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Tag;                                               // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVerticalAlignment                            VerticalAlignment;                                 // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EDynamicHUDAnchor                             Anchor;                                            // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintAlignment">();
	}
	static class UDynamicHUDConstraintAlignment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintAlignment>();
	}
};
static_assert(alignof(UDynamicHUDConstraintAlignment) == 0x000008, "Wrong alignment on UDynamicHUDConstraintAlignment");
static_assert(sizeof(UDynamicHUDConstraintAlignment) == 0x000068, "Wrong size on UDynamicHUDConstraintAlignment");
static_assert(offsetof(UDynamicHUDConstraintAlignment, Widget) == 0x000030, "Member 'UDynamicHUDConstraintAlignment::Widget' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintAlignment, Tag) == 0x000058, "Member 'UDynamicHUDConstraintAlignment::Tag' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintAlignment, HorizontalAlignment) == 0x000060, "Member 'UDynamicHUDConstraintAlignment::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintAlignment, VerticalAlignment) == 0x000061, "Member 'UDynamicHUDConstraintAlignment::VerticalAlignment' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintAlignment, Anchor) == 0x000064, "Member 'UDynamicHUDConstraintAlignment::Anchor' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintWidget
// 0x0070 (0x00A0 - 0x0030)
class UDynamicHUDConstraintWidget final : public UDynamicHUDConstraintBase
{
public:
	TSoftClassPtr<class UClass>                   WidgetA;                                           // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagA;                                              // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDAnchor                             AnchorA;                                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WidgetB;                                           // 0x0068(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagB;                                              // 0x0090(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDAnchor                             AnchorB;                                           // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintWidget">();
	}
	static class UDynamicHUDConstraintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintWidget>();
	}
};
static_assert(alignof(UDynamicHUDConstraintWidget) == 0x000008, "Wrong alignment on UDynamicHUDConstraintWidget");
static_assert(sizeof(UDynamicHUDConstraintWidget) == 0x0000A0, "Wrong size on UDynamicHUDConstraintWidget");
static_assert(offsetof(UDynamicHUDConstraintWidget, WidgetA) == 0x000030, "Member 'UDynamicHUDConstraintWidget::WidgetA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, TagA) == 0x000058, "Member 'UDynamicHUDConstraintWidget::TagA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, AnchorA) == 0x000060, "Member 'UDynamicHUDConstraintWidget::AnchorA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, WidgetB) == 0x000068, "Member 'UDynamicHUDConstraintWidget::WidgetB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, TagB) == 0x000090, "Member 'UDynamicHUDConstraintWidget::TagB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintWidget, AnchorB) == 0x000098, "Member 'UDynamicHUDConstraintWidget::AnchorB' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintComparison
// 0x0078 (0x00A8 - 0x0030)
class UDynamicHUDConstraintComparison final : public UDynamicHUDConstraintBase
{
public:
	TSoftClassPtr<class UClass>                   WidgetA;                                           // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagA;                                              // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDSide                               SideA;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetA;                                           // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDComparison                         Comparison;                                        // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WidgetB;                                           // 0x0070(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagB;                                              // 0x0098(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDSide                               SideB;                                             // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetB;                                           // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintComparison">();
	}
	static class UDynamicHUDConstraintComparison* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintComparison>();
	}
};
static_assert(alignof(UDynamicHUDConstraintComparison) == 0x000008, "Wrong alignment on UDynamicHUDConstraintComparison");
static_assert(sizeof(UDynamicHUDConstraintComparison) == 0x0000A8, "Wrong size on UDynamicHUDConstraintComparison");
static_assert(offsetof(UDynamicHUDConstraintComparison, WidgetA) == 0x000030, "Member 'UDynamicHUDConstraintComparison::WidgetA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, TagA) == 0x000058, "Member 'UDynamicHUDConstraintComparison::TagA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, SideA) == 0x000060, "Member 'UDynamicHUDConstraintComparison::SideA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, OffsetA) == 0x000064, "Member 'UDynamicHUDConstraintComparison::OffsetA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, Comparison) == 0x000068, "Member 'UDynamicHUDConstraintComparison::Comparison' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, WidgetB) == 0x000070, "Member 'UDynamicHUDConstraintComparison::WidgetB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, TagB) == 0x000098, "Member 'UDynamicHUDConstraintComparison::TagB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, SideB) == 0x0000A0, "Member 'UDynamicHUDConstraintComparison::SideB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintComparison, OffsetB) == 0x0000A4, "Member 'UDynamicHUDConstraintComparison::OffsetB' has a wrong offset!");

// Class DynamicHUD.DynamicHUDConstraintEquation
// 0x0078 (0x00A8 - 0x0030)
class UDynamicHUDConstraintEquation final : public UDynamicHUDConstraintBase
{
public:
	TSoftClassPtr<class UClass>                   WidgetA;                                           // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagA;                                              // 0x0058(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDSide                               SideA;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDOperator                           Operator;                                          // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   WidgetB;                                           // 0x0068(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TagB;                                              // 0x0090(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDSide                               SideB;                                             // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicHUDComparison                         Comparison;                                        // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Result;                                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDConstraintEquation">();
	}
	static class UDynamicHUDConstraintEquation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDConstraintEquation>();
	}
};
static_assert(alignof(UDynamicHUDConstraintEquation) == 0x000008, "Wrong alignment on UDynamicHUDConstraintEquation");
static_assert(sizeof(UDynamicHUDConstraintEquation) == 0x0000A8, "Wrong size on UDynamicHUDConstraintEquation");
static_assert(offsetof(UDynamicHUDConstraintEquation, WidgetA) == 0x000030, "Member 'UDynamicHUDConstraintEquation::WidgetA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, TagA) == 0x000058, "Member 'UDynamicHUDConstraintEquation::TagA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, SideA) == 0x000060, "Member 'UDynamicHUDConstraintEquation::SideA' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, Operator) == 0x000064, "Member 'UDynamicHUDConstraintEquation::Operator' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, WidgetB) == 0x000068, "Member 'UDynamicHUDConstraintEquation::WidgetB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, TagB) == 0x000090, "Member 'UDynamicHUDConstraintEquation::TagB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, SideB) == 0x000098, "Member 'UDynamicHUDConstraintEquation::SideB' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, Comparison) == 0x00009C, "Member 'UDynamicHUDConstraintEquation::Comparison' has a wrong offset!");
static_assert(offsetof(UDynamicHUDConstraintEquation, Result) == 0x0000A0, "Member 'UDynamicHUDConstraintEquation::Result' has a wrong offset!");

// Class DynamicHUD.DynamicHUDManager
// 0x00C8 (0x00F8 - 0x0030)
class UDynamicHUDManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDynamicHUDScene*, uint8>          ActiveScenes;                                      // 0x0050(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FDirectorData>     ActiveDirectors;                                   // 0x00A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UDynamicHUDWidgetCatalog*               CurrentWidgetCatalog;                              // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddScene(const class UDynamicHUDScene* Scene);
	void AddScenes(const TArray<class UDynamicHUDScene*>& Scenes);
	class UDynamicHUDWidgetCatalog* GetCurrentWidgetCatalog();
	void RemoveScene(const class UDynamicHUDScene* Scene);
	void RemoveScenes(const TArray<class UDynamicHUDScene*>& Scenes);
	void SetCurrentWidgetCatalog(class UDynamicHUDWidgetCatalog* InWidgetCatalog);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDManager">();
	}
	static class UDynamicHUDManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDManager>();
	}
};
static_assert(alignof(UDynamicHUDManager) == 0x000008, "Wrong alignment on UDynamicHUDManager");
static_assert(sizeof(UDynamicHUDManager) == 0x0000F8, "Wrong size on UDynamicHUDManager");
static_assert(offsetof(UDynamicHUDManager, ActiveScenes) == 0x000050, "Member 'UDynamicHUDManager::ActiveScenes' has a wrong offset!");
static_assert(offsetof(UDynamicHUDManager, ActiveDirectors) == 0x0000A0, "Member 'UDynamicHUDManager::ActiveDirectors' has a wrong offset!");
static_assert(offsetof(UDynamicHUDManager, CurrentWidgetCatalog) == 0x0000F0, "Member 'UDynamicHUDManager::CurrentWidgetCatalog' has a wrong offset!");

// Class DynamicHUD.DynamicHUDScene
// 0x0050 (0x0080 - 0x0030)
class UDynamicHUDScene final : public UDataAsset
{
public:
	TArray<TSoftClassPtr<class UClass>>           Allowed;                                           // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Unallowed;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   AllowedTags;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   UnallowedTags;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDynamicHUDConstraintBase*>      LayoutConstraints;                                 // 0x0070(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDScene">();
	}
	static class UDynamicHUDScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDScene>();
	}
};
static_assert(alignof(UDynamicHUDScene) == 0x000008, "Wrong alignment on UDynamicHUDScene");
static_assert(sizeof(UDynamicHUDScene) == 0x000080, "Wrong size on UDynamicHUDScene");
static_assert(offsetof(UDynamicHUDScene, Allowed) == 0x000030, "Member 'UDynamicHUDScene::Allowed' has a wrong offset!");
static_assert(offsetof(UDynamicHUDScene, Unallowed) == 0x000040, "Member 'UDynamicHUDScene::Unallowed' has a wrong offset!");
static_assert(offsetof(UDynamicHUDScene, AllowedTags) == 0x000050, "Member 'UDynamicHUDScene::AllowedTags' has a wrong offset!");
static_assert(offsetof(UDynamicHUDScene, UnallowedTags) == 0x000060, "Member 'UDynamicHUDScene::UnallowedTags' has a wrong offset!");
static_assert(offsetof(UDynamicHUDScene, LayoutConstraints) == 0x000070, "Member 'UDynamicHUDScene::LayoutConstraints' has a wrong offset!");

// Class DynamicHUD.DynamicHUDVisualizerWidget
// 0x0030 (0x0290 - 0x0260)
class UDynamicHUDVisualizerWidget final : public UUserWidget
{
public:
	TArray<class UDynamicHUDScene*>               Scenes;                                            // 0x0260(0x0010)(Edit, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicHUDWidgetCatalog*               WidgetCatalog;                                     // 0x0270(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRefresh;                                          // 0x0278(0x0001)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x17];                                     // 0x0279(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDVisualizerWidget">();
	}
	static class UDynamicHUDVisualizerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDVisualizerWidget>();
	}
};
static_assert(alignof(UDynamicHUDVisualizerWidget) == 0x000008, "Wrong alignment on UDynamicHUDVisualizerWidget");
static_assert(sizeof(UDynamicHUDVisualizerWidget) == 0x000290, "Wrong size on UDynamicHUDVisualizerWidget");
static_assert(offsetof(UDynamicHUDVisualizerWidget, Scenes) == 0x000260, "Member 'UDynamicHUDVisualizerWidget::Scenes' has a wrong offset!");
static_assert(offsetof(UDynamicHUDVisualizerWidget, WidgetCatalog) == 0x000270, "Member 'UDynamicHUDVisualizerWidget::WidgetCatalog' has a wrong offset!");
static_assert(offsetof(UDynamicHUDVisualizerWidget, bRefresh) == 0x000278, "Member 'UDynamicHUDVisualizerWidget::bRefresh' has a wrong offset!");

// Class DynamicHUD.DynamicHUDWidgetCatalog
// 0x0050 (0x0080 - 0x0030)
class UDynamicHUDWidgetCatalog final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FWidgetCatalogEntryClass> MapOfEntries;                         // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicHUDWidgetCatalog">();
	}
	static class UDynamicHUDWidgetCatalog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicHUDWidgetCatalog>();
	}
};
static_assert(alignof(UDynamicHUDWidgetCatalog) == 0x000008, "Wrong alignment on UDynamicHUDWidgetCatalog");
static_assert(sizeof(UDynamicHUDWidgetCatalog) == 0x000080, "Wrong size on UDynamicHUDWidgetCatalog");
static_assert(offsetof(UDynamicHUDWidgetCatalog, MapOfEntries) == 0x000030, "Member 'UDynamicHUDWidgetCatalog::MapOfEntries' has a wrong offset!");

}

