#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: UnstableLiquidGunRuntime

#include "Basic.hpp"

#include "UnstableLiquidGunRuntime_classes.hpp"
#include "UnstableLiquidGunRuntime_parameters.hpp"


namespace SDK
{

// Function UnstableLiquidGunRuntime.FortLiquidGunProjectile.HandleSplineHit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFortLiquidGunProjectile::HandleSplineHit(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleSplineHit");

	Params::FortLiquidGunProjectile_HandleSplineHit Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UnstableLiquidGunRuntime.FortLiquidGunProjectile.SetDetachmentReason
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELiquidRibbonDetachmentReason           InDetachmentReason                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortLiquidGunProjectile::SetDetachmentReason(ELiquidRibbonDetachmentReason InDetachmentReason)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetDetachmentReason");

	Params::FortLiquidGunProjectile_SetDetachmentReason Parms{};

	Parms.InDetachmentReason = InDetachmentReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function UnstableLiquidGunRuntime.FortLiquidGunProjectile.GetDetachmentReason
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELiquidRibbonDetachmentReason           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELiquidRibbonDetachmentReason AFortLiquidGunProjectile::GetDetachmentReason() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetDetachmentReason");

	Params::FortLiquidGunProjectile_GetDetachmentReason Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculateSegments
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Tension                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLiquidRibbonSplineSegment>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLiquidRibbonSplineSegment> ALiquidRibbonManager::CalculateSegments(const TArray<struct FVector>& Points, const float Tension)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalculateSegments");

	Params::LiquidRibbonManager_CalculateSegments Parms{};

	Parms.Points = std::move(Points);
	Parms.Tension = Tension;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculateSplinePointsAndSetNiagaraData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AFortLiquidGunProjectile*> Projectiles                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAttachSplineToMuzzle                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutAllPositions                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           OutRibbonIDs                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>                            OutRibbonVisibilities                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           OutFlashIntensities                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           OutRibbonSizes                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALiquidRibbonManager::CalculateSplinePointsAndSetNiagaraData(const TArray<class AFortLiquidGunProjectile*>& Projectiles, bool bAttachSplineToMuzzle, class UNiagaraComponent* NiagaraComponent, TArray<struct FVector>* OutAllPositions, TArray<int32>* OutRibbonIDs, TArray<bool>* OutRibbonVisibilities, TArray<float>* OutFlashIntensities, TArray<int32>* OutRibbonSizes)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalculateSplinePointsAndSetNiagaraData");

	Params::LiquidRibbonManager_CalculateSplinePointsAndSetNiagaraData Parms{};

	Parms.Projectiles = std::move(Projectiles);
	Parms.bAttachSplineToMuzzle = bAttachSplineToMuzzle;
	Parms.NiagaraComponent = NiagaraComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (OutAllPositions != nullptr)
		*OutAllPositions = std::move(Parms.OutAllPositions);

	if (OutRibbonIDs != nullptr)
		*OutRibbonIDs = std::move(Parms.OutRibbonIDs);

	if (OutRibbonVisibilities != nullptr)
		*OutRibbonVisibilities = std::move(Parms.OutRibbonVisibilities);

	if (OutFlashIntensities != nullptr)
		*OutFlashIntensities = std::move(Parms.OutFlashIntensities);

	if (OutRibbonSizes != nullptr)
		*OutRibbonSizes = std::move(Parms.OutRibbonSizes);
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.GetOrAddDetachment
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   RibbonID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLiquidRibbonSplineSegment       Segment                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FLiquidRibbonSplineDetachmentReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FLiquidRibbonSplineDetachment ALiquidRibbonManager::GetOrAddDetachment(const int32 RibbonID, const struct FLiquidRibbonSplineSegment& Segment)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetOrAddDetachment");

	Params::LiquidRibbonManager_GetOrAddDetachment Parms{};

	Parms.RibbonID = RibbonID;
	Parms.Segment = std::move(Segment);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.RunSplineCollisionTestOnProjectiles
// (Final, Native, Public, BlueprintCallable)

void ALiquidRibbonManager::RunSplineCollisionTestOnProjectiles()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RunSplineCollisionTestOnProjectiles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculatePointFlashIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointSize                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALiquidRibbonManager::CalculatePointFlashIntensity(const int32 PointSize) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalculatePointFlashIntensity");

	Params::LiquidRibbonManager_CalculatePointFlashIntensity Parms{};

	Parms.PointSize = PointSize;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculatePointSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SegmentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALiquidRibbonManager::CalculatePointSize(int32 SegmentIndex, int32 PointIndex) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("CalculatePointSize");

	Params::LiquidRibbonManager_CalculatePointSize Parms{};

	Parms.SegmentIndex = SegmentIndex;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.GetFirstVisiblePointIndex
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALiquidRibbonManager::GetFirstVisiblePointIndex() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetFirstVisiblePointIndex");

	Params::LiquidRibbonManager_GetFirstVisiblePointIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.GetPointOnSegment
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   T                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLiquidRibbonSplineSegment       Segment                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALiquidRibbonManager::GetPointOnSegment(float T, const struct FLiquidRibbonSplineSegment& Segment) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetPointOnSegment");

	Params::LiquidRibbonManager_GetPointOnSegment Parms{};

	Parms.T = T;
	Parms.Segment = std::move(Segment);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.SetNiagaraData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           RibbonIDs                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<bool>                            RibbonVisibilities                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<float>                           FlashIntensities                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           RibbonSizes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALiquidRibbonManager::SetNiagaraData(class UNiagaraComponent* NiagaraComponent, const TArray<struct FVector>& Positions, const TArray<int32>& RibbonIDs, const TArray<bool>& RibbonVisibilities, const TArray<float>& FlashIntensities, const TArray<int32>& RibbonSizes) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetNiagaraData");

	Params::LiquidRibbonManager_SetNiagaraData Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.Positions = std::move(Positions);
	Parms.RibbonIDs = std::move(RibbonIDs);
	Parms.RibbonVisibilities = std::move(RibbonVisibilities);
	Parms.FlashIntensities = std::move(FlashIntensities);
	Parms.RibbonSizes = std::move(RibbonSizes);

	UObject::ProcessEvent(Func, &Parms);
}

}

