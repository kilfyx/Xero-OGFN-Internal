#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VerseCore

#include "Basic.hpp"

#include "SolarisInterop_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "ModularGameplay_classes.hpp"
#include "Engine_classes.hpp"
#include "NetworkPrediction_structs.hpp"
#include "VerseCore_structs.hpp"


namespace SDK
{

// Class VerseCore.VerseAssetPtr
// 0x0038 (0x0068 - 0x0030)
class UVerseAssetPtr : public UVerseAsset
{
public:
	class FName                                   AssetPathName;                                     // 0x0030(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                Object;                                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AssetPathName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerseAssetPtr">();
	}
	static class UVerseAssetPtr* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerseAssetPtr>();
	}
};
static_assert(alignof(UVerseAssetPtr) == 0x000008, "Wrong alignment on UVerseAssetPtr");
static_assert(sizeof(UVerseAssetPtr) == 0x000068, "Wrong size on UVerseAssetPtr");
static_assert(offsetof(UVerseAssetPtr, AssetPathName) == 0x000030, "Member 'UVerseAssetPtr::AssetPathName' has a wrong offset!");
static_assert(offsetof(UVerseAssetPtr, Object) == 0x000038, "Member 'UVerseAssetPtr::Object' has a wrong offset!");

// Class VerseCore.ControllerStateComponent
// 0x0030 (0x00E0 - 0x00B0)
class UControllerStateComponent final : public UControllerComponent
{
public:
	TArray<class FString>                         ActiveStates;                                      // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ActiveStates();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerStateComponent">();
	}
	static class UControllerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerStateComponent>();
	}
};
static_assert(alignof(UControllerStateComponent) == 0x000008, "Wrong alignment on UControllerStateComponent");
static_assert(sizeof(UControllerStateComponent) == 0x0000E0, "Wrong size on UControllerStateComponent");
static_assert(offsetof(UControllerStateComponent, ActiveStates) == 0x0000B0, "Member 'UControllerStateComponent::ActiveStates' has a wrong offset!");

// Class VerseCore.ObjectHack
// 0x0000 (0x0028 - 0x0028)
class UObjectHack final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectHack">();
	}
	static class UObjectHack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectHack>();
	}
};
static_assert(alignof(UObjectHack) == 0x000008, "Wrong alignment on UObjectHack");
static_assert(sizeof(UObjectHack) == 0x000028, "Wrong size on UObjectHack");

// Class VerseCore.VerseWorldSubsystem
// 0x0018 (0x0048 - 0x0030)
class UVerseWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VerseWorldSubsystem">();
	}
	static class UVerseWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVerseWorldSubsystem>();
	}
};
static_assert(alignof(UVerseWorldSubsystem) == 0x000008, "Wrong alignment on UVerseWorldSubsystem");
static_assert(sizeof(UVerseWorldSubsystem) == 0x000048, "Wrong size on UVerseWorldSubsystem");

// Class VerseCore.VUIActor
// 0x02D0 (0x04F0 - 0x0220)
class AVUIActor final : public AActor
{
public:
	class UClass*                                 SolarisClass;                                      // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVUIRuntimeMapping>             RuntimeMapping;                                    // 0x0228(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVUIRuntimeEventMapping>        RuntimeFunctionMapping;                            // 0x0238(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVUIRuntimeInputMapping>        RuntimeInputMapping;                               // 0x0248(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                SpawnedBrainObjRef;                                // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ReplicatedPlayerController;                        // 0x0268(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x20];                                     // 0x0270(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNetworkPredictionProxy                NetworkPredictionProxy;                            // 0x0290(0x00B0)(Net, Transient, NativeAccessSpecifierPublic)
	struct FReplicationProxy                      ReplicationProxy_ServerRPC;                        // 0x0340(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x50];                                     // 0x0390(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    NetworkPredictionPrimitive;                        // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicationProxy                      ReplicationProxy_Autonomous;                       // 0x03F0(0x0050)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FReplicationProxy                      ReplicationProxy_Simulated;                        // 0x0440(0x0050)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FReplicationProxy                      ReplicationProxy_Replay;                           // 0x0490(0x0050)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0x10];                                     // 0x04E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDrawHUD(class AHUD* HUD, class UCanvas* Canvas);
	void OnPossessed(class APlayerController* Controller);
	void OnRep_PlayerController(class APlayerController* OldPC);
	void OnUnPossessed(class APlayerController* OldController);
	void ServerReceiveClientInput(const struct FServerReplicationRPCParameter& ProxyParameter);

	class APlayerController* GetController() const;
	int32 GetVUIMode() const;
	class UObject* K2_GetSpawnedBrainObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VUIActor">();
	}
	static class AVUIActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVUIActor>();
	}
};
static_assert(alignof(AVUIActor) == 0x000010, "Wrong alignment on AVUIActor");
static_assert(sizeof(AVUIActor) == 0x0004F0, "Wrong size on AVUIActor");
static_assert(offsetof(AVUIActor, SolarisClass) == 0x000220, "Member 'AVUIActor::SolarisClass' has a wrong offset!");
static_assert(offsetof(AVUIActor, RuntimeMapping) == 0x000228, "Member 'AVUIActor::RuntimeMapping' has a wrong offset!");
static_assert(offsetof(AVUIActor, RuntimeFunctionMapping) == 0x000238, "Member 'AVUIActor::RuntimeFunctionMapping' has a wrong offset!");
static_assert(offsetof(AVUIActor, RuntimeInputMapping) == 0x000248, "Member 'AVUIActor::RuntimeInputMapping' has a wrong offset!");
static_assert(offsetof(AVUIActor, SpawnedBrainObjRef) == 0x000258, "Member 'AVUIActor::SpawnedBrainObjRef' has a wrong offset!");
static_assert(offsetof(AVUIActor, ReplicatedPlayerController) == 0x000268, "Member 'AVUIActor::ReplicatedPlayerController' has a wrong offset!");
static_assert(offsetof(AVUIActor, NetworkPredictionProxy) == 0x000290, "Member 'AVUIActor::NetworkPredictionProxy' has a wrong offset!");
static_assert(offsetof(AVUIActor, ReplicationProxy_ServerRPC) == 0x000340, "Member 'AVUIActor::ReplicationProxy_ServerRPC' has a wrong offset!");
static_assert(offsetof(AVUIActor, NetworkPredictionPrimitive) == 0x0003E0, "Member 'AVUIActor::NetworkPredictionPrimitive' has a wrong offset!");
static_assert(offsetof(AVUIActor, ReplicationProxy_Autonomous) == 0x0003F0, "Member 'AVUIActor::ReplicationProxy_Autonomous' has a wrong offset!");
static_assert(offsetof(AVUIActor, ReplicationProxy_Simulated) == 0x000440, "Member 'AVUIActor::ReplicationProxy_Simulated' has a wrong offset!");
static_assert(offsetof(AVUIActor, ReplicationProxy_Replay) == 0x000490, "Member 'AVUIActor::ReplicationProxy_Replay' has a wrong offset!");

// Class VerseCore.VUIDynamicEventBinding
// 0x0010 (0x0038 - 0x0028)
class UVUIDynamicEventBinding final : public UDynamicBlueprintBinding
{
public:
	TArray<struct FVUIDynamicEventBindingData>    EventBindings;                                     // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VUIDynamicEventBinding">();
	}
	static class UVUIDynamicEventBinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVUIDynamicEventBinding>();
	}
};
static_assert(alignof(UVUIDynamicEventBinding) == 0x000008, "Wrong alignment on UVUIDynamicEventBinding");
static_assert(sizeof(UVUIDynamicEventBinding) == 0x000038, "Wrong size on UVUIDynamicEventBinding");
static_assert(offsetof(UVUIDynamicEventBinding, EventBindings) == 0x000028, "Member 'UVUIDynamicEventBinding::EventBindings' has a wrong offset!");

}

