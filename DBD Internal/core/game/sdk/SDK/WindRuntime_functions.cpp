#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: WindRuntime

#include "Basic.hpp"

#include "WindRuntime_classes.hpp"
#include "WindRuntime_parameters.hpp"


namespace SDK
{

// Function WindRuntime.WindCheatManager.InflateBalloonOnSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Public, Const)
// Parameters:
// int32                                   NumBalloons                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindCheatManager::InflateBalloonOnSelf(int32 NumBalloons) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("InflateBalloonOnSelf");

	Params::WindCheatManager_InflateBalloonOnSelf Parms{};

	Parms.NumBalloons = NumBalloons;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindCheatManager.ReleaseBalloonOnSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Public, Const)
// Parameters:
// int32                                   NumBalloons                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindCheatManager::ReleaseBalloonOnSelf(int32 NumBalloons) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("ReleaseBalloonOnSelf");

	Params::WindCheatManager_ReleaseBalloonOnSelf Parms{};

	Parms.NumBalloons = NumBalloons;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.AddCollider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  ShapeComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindField::AddCollider(class UShapeComponent* ShapeComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddCollider");

	Params::WindField_AddCollider Parms{};

	Parms.ShapeComponent = ShapeComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindField::AddIgnoredActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("AddIgnoredActor");

	Params::WindField_AddIgnoredActor Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.OnBeginOverlap
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AWindField::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnBeginOverlap");

	Params::WindField_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.OnEndOverlap
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindField::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnEndOverlap");

	Params::WindField_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.RemoveCollider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UShapeComponent*                  ShapeComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindField::RemoveCollider(class UShapeComponent* ShapeComponent)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveCollider");

	Params::WindField_RemoveCollider Parms{};

	Parms.ShapeComponent = ShapeComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.RemoveIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindField::RemoveIgnoredActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("RemoveIgnoredActor");

	Params::WindField_RemoveIgnoredActor Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindField.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindField::SetActive(bool bInIsActive)
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("SetActive");

	Params::WindField_SetActive Parms{};

	Parms.bInIsActive = bInIsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function WindRuntime.WindSplineComponent.Disable
// (Final, Native, Protected)

void UWindSplineComponent::Disable()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Disable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function WindRuntime.WindSplineComponent.Enable
// (Final, Native, Protected)

void UWindSplineComponent::Enable()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("Enable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function WindRuntime.WindSplineComponent.HandleSafeZoneUpdated
// (Final, Native, Protected)

void UWindSplineComponent::HandleSafeZoneUpdated()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("HandleSafeZoneUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function WindRuntime.WindSplineComponent.OnRep_Blockages
// (Final, Native, Protected)

void UWindSplineComponent::OnRep_Blockages()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_Blockages");

	UObject::ProcessEvent(Func, nullptr);
}


// Function WindRuntime.WindSplineComponent.OnRep_TargetData
// (Final, Native, Protected)

void UWindSplineComponent::OnRep_TargetData()
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("OnRep_TargetData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function WindRuntime.WindSplineComponent.GetClosestActiveLocations
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          InTargetLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsClosestPointActive                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ClosestPointOnSpline                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ClosestActiveLocations                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UWindSplineComponent::GetClosestActiveLocations(const struct FVector& InTargetLocation, bool* bIsClosestPointActive, struct FVector* ClosestPointOnSpline, TArray<struct FVector>* ClosestActiveLocations) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetClosestActiveLocations");

	Params::WindSplineComponent_GetClosestActiveLocations Parms{};

	Parms.InTargetLocation = std::move(InTargetLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (bIsClosestPointActive != nullptr)
		*bIsClosestPointActive = Parms.bIsClosestPointActive;

	if (ClosestPointOnSpline != nullptr)
		*ClosestPointOnSpline = std::move(Parms.ClosestPointOnSpline);

	if (ClosestActiveLocations != nullptr)
		*ClosestActiveLocations = std::move(Parms.ClosestActiveLocations);
}


// Function WindRuntime.WindSplineComponent.GetTargetingRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWindSplineComponent::GetTargetingRadius() const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetTargetingRadius");

	Params::WindSplineComponent_GetTargetingRadius Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function WindRuntime.WindSplineComponent.GetWindDataAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          InTargetLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutDirection                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutAttenuation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWindSplineComponent::GetWindDataAtLocation(const struct FVector& InTargetLocation, struct FVector* OutDirection, float* OutAttenuation) const
{
	static class UFunction* Func = nullptr;
	
	if (Func == nullptr)
		Func = Class->FindFunction("GetWindDataAtLocation");

	Params::WindSplineComponent_GetWindDataAtLocation Parms{};

	Parms.InTargetLocation = std::move(InTargetLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (OutDirection != nullptr)
		*OutDirection = std::move(Parms.OutDirection);

	if (OutAttenuation != nullptr)
		*OutAttenuation = Parms.OutAttenuation;
}

}

